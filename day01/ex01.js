// 1. 비동기적 방식 
// 2. 싱글스레드 (한번에 하나의 일만 처리할 수 있음)
// 3. 이벤트 기반 (이벤트가 발생했을 때만 수행 -> 자원을 최소화) 
// 4. 콜백함수 사용 

console.log('Node Success!✨')

// 그 전에는 js파일은? Chrome > F12 > Console : 무조건 Front-end 
// 저희는 이제 node js 로 실행을 시킬 것 : 이제부터는 Back-end 
// 어떻게 실행을 할거냐?
// 터미널 (Terminal) > 새 터미널 (New Terminal)
// 'node' Enter > Welcome~ 노드가 설치되어있다는 확인 문구 
// 빠져나오는 방법? Ctrl+C 두번  


// C:\Users\SMHRD\Dropbox\syp\리허설\nodeJS\yp-code> 
// 앞쪽은 현재 우리의 위치 

// 지금 우리가 있는 위치의 폴더 안에 어떤게 있는지 확인하려면? ls 
// 폴더 안으로 들어가보기 d -- : directory (폴더) / change directory 
// cd day01 : day01 이라는 폴더 안으로 들어가겠다. 
// 한번 더 ls 하면 우리가 만든 파일이 보임 

// 우리는 이제 node js 로 실행시켜볼거임 node ex01.js


// ** 메모장 정리 **
// Ctrl+C 명령취소 / 종료 
// ls : 파일 확인 (list directory contents)
// cd : 폴더 이동 (change directory )
// clear : 이 전 명령 삭제 
// node [js파일명] : node js 실행 
// 방향키 ↑ : 그 전 썼던 명령어들
// 파일 명이 길어지면 오타날 확률이 있음! 
// Tab : 자동생성 


// if, day01 인 상태에서 day02로 이동하고싶다면?
// cd day02 -> X 이게 말이 되려면 day01 안에 day02가 있어야함! 
// 한번 상위로 나가는거? cd ..


// 지금 우리는 Terminal 에서 작업 중,
// 명령창에서 폴더 이동, 파일 실행 실행시키는 인터페이스 : CLI (Comment Line Interface)
// 나머지 영역은 Window에서 제공하는 인터페이스 : GUI (Graphic User Interface)
// CLI같은 경우는 서버 (Linux)

// GUI Window 는 개인용 PC에 적합
// CLI Linux 는 서버 PC에 적합 
// Why? 만약 내가 컴퓨터가 두대가 있다 100개의 일을 처리할 수 있는 컴퓨터 
// GUI Window 같은 경우는 사용자가 사용하기 편해야하니까 그래픽들을 다 만들고 시작 
//          -> 여기서 많은 메모리를 소진한다. 
// CLI Linux 같은 경우는 어차피 모든게 명령어 기반이기 때문에 메모리를 많이 안먹음 
//          -> 효율적인 메모리 사용 가능 
// 서버같은 경우는 많은 사람들의 요청에 응답을 해주는게 이 서버가 하는 역할이기 때문에 
// 대부분은 Linux로! 

// 이제는 ex01.js를 실제 서버파일로 만들어줄거다. => Module 시작 


// =====================================================

// 기본적으로 nodeJS 를 설치를 하면 굉장히 많은 기능들을 가지고 있다.
// 저희는 그 기능을 가져다가 쓰면 되는데 그 기능들의 단위를 모듈이라고 한다. 

//  >> PPT page 2

// 자바에서는 그 기능들의 단위를 라이브러리 개념이라고 하는데 nodeJS에서는 모듈이라고 할거다.  - > ex01.js 58 Line  

// 모듈은 부품같은 역할을 하므로 여러 부품들을 조합해서 하나의 프로그램을 만든다고 생각하면 좋음 

// ex) 어떤 프로그램을 만들지 모르는 상황이라도 멤버를 받는 웹 서비스에서는 필요한 공통적인 기능들 => 회원가입, 로그인 등 
// 이런 기능을 이루는 코드를 미리 모아서 캡슐화 해둔 것을 '모듈' 이라고 함 모듈은 애플리케이션을 구성하는 기본 단위 
// 기능별로 코딩이 가능하고 모듈로 묶어 놓은 코드의 재사용이 가능하기 때문에 정말 편리! 

// >> PPT page 3
// nodeJS에서 모듈을 가져올때 사용하는 명령어가 require 라는 명령어 
// 뭘 가져올거냐면, ex01.js 를 서버로 만들어줄 수 있는 모듈을 가져올거야! 
// http 라는 모듈을 가지고 오는 것  -> 가져와서 이걸 변수로 지정해줄거임 

// ** code in 
// ** 모듈 : Node js에서 만들어 둔 기능들의 단위 
const http = require('http');
const { report } = require('process');
// ** require : module을 가져오는 명령어 
// ** http모듈 : 현재 파일을 서버로 만들어주는 명령어 

// 자 그러면 이제 http 모듈을 통해 서버를 만들어 볼 것! 
// 우리가 지금 했던 과정은 가지고 오기만 한 것 
// http 모듈이 가지고 있는 기능 중 실제로 서버를 만들어주는 기능을 써야함

// java 에서도 Scanner sc = new Scanner(); 
// 이렇게만 했다고 명령문을 쓸 수 있는게 아니었음 sc.nextInt(); 

// 가지고 왔다고만해서 서버로 만들어진게 아니라 http가 가지고 있는 기능을 
// 안에서 써줘야했음 

http.createServer(function (request, response) {
    // 중괄호안에는 뭘 실행시킬건지? 
    // 여러분 우리 저번시간에 했던 함수 안의 함수? 콜백함수 
    // 해석 해볼게요. http모듈을 활용해서 서버를 만들었습니다. > 1번함수
    // 실제 서버로 들어온 사람의 요청을 처리해주기 위한 함수 > 2번 함수 

    // 누군가가 이 서버에 접근을 할 것 
    // 사용자의 요청을 대기할 수 있는 방, 포트번호를 설정 
    // listen(3000)

    console.log('Server 실행 중!⚡️');

    // request, response, listen 은 뒤에서 알려줌 

    // 실행 -> 아까랑 다른 점? 멈춰있음 
    // ex01.js를 실행하면 실제 node JS 프로그램에 의해 실행이 됨
    // http~를 만나는 순간 멈춘다. 우리한테는 1번, 2번 두개의 함수가 존재
    // 1번을 만나면 여기에서 기다리고 있는거임 누군가가 나를 호출해줄 때까지
    // 서버가 하는 역할이 뭐라고 했어요? 사용자가 요청을 하면 응답을 해준다고 했잖아요?
    // 사용자가 ex01.js를 요청하기를 기다리고 있다는 뜻 

    // 실제로 쟤를 실행하려면? 브라우저창 켜보세요 -> 시작 -> cmd 입력 '명령프롬프트'
    //  -> 여기에다가 'ip config' 입력 -> 여러분들 집에도 주소가 있듯이 여러분들이 쓰는 컴퓨터에도 고유한 주소가 있음 (ip)
    // IPv4주소 라고 나온 부분이 여러분들 컴퓨터 고유의 주소 -> IP를 그대로 복사해서 메모장에 붙여넣기 

    // url 주소 창에 본인 ip + 콜론 3000 입력 > 서버 실행 성공 
    // 왜 실행 됐을까? 우리가 브라우저 창을 통해서 ex01.js를 요청 한 것 > 서버 실행 완료 

    // 여기서 url 단톡방에다가 올리라고 하고 서로의 서버에 들어가보는 시간가짐 
    // IP, PORT 설명 

    // ** listen: port번호설정 (방번호) 



    // createServer 1번 함수 
    // 그 안에 있는 function(){}이 2번 함수 -> 가지고 있는 매개변수 request, reponse ★ 웹의 핵심
    // Node에만 있는 개념이 아님 모든 웹프로그램에 있는 개념!
    // 왜냐하면 서버와 통신 하기 위해서 무조건 HTTP라는 프로토콜을 사용한다.
    // HTTP가 가진 애중에 request, response 라는 개념이 존재 

    // 사용자가 딱 접근을 할때 사용자의 모든 정보를 가지고 있는 것 : request 
    // -> 확인! 
    let ip = request.connection.remoteAddress; //내 컴퓨터에 접근한 사람의 ip주소
    // console.log('접근한 Client의 ip : '+ip);

    // 단톡방에 공유해보기!
    // ffff가 나타나는 이유? IP4V방식 IP6V방식 
    // 우리가 알고있는 000 네번반복하는 체계 -> IP4V 이제 할당 IP가 다 참 
    // 그래서 한자리에 네자리수로 반복하는 체계 -> IP6V 
    // 출력 방식 IP6V, 출력 내용 IPv4V 
    
    // 문자열을 잘라주는 기능 
    let ip_res = ip.substring(7);
    console.log('접근한 Client의 ip : '+ip_res);

    // ex) 네이버에서 어떤 값을 검색하거나, 로그인, 회원가입 전부 어떤 값을 입력 -> 서버는 그 값들을 다 받게 됨 
    // 우리는 나중에 request로 그 정보들을 다 가지고 와 볼거다! 

    // ** request : Client의 모든 정보를 갖고있는 객체

    // 우리가 만든 서버의 문제점? 접근 시 계속해서 새로고침이 되고있음 동골동골 
    //  >> 서버가 나한테 어떤 값을 응답을 안해주고 있는거임 계속 기다리고 있음 응답이 올 때까지
    // 이제 서버가 나한테 응답해주는 작업을 해볼 것! 

    response.writeHead(200,{"Content-Type" : "text/html;charset=utf-8"});
    // 클라이언트  >요청 <응답 서버 
    // 실제 보내는 데이터의 단위 : 패킷 단위로 서버에게 요청을 함 
    // 패킷은 두가지로 구성 -> 어떤 사용자가 어떤 데이터를 보내는지 header, 실제 그 데이터를 담고있는 body 
    // response.writeHead()? 서버가 사용자에게 응답할때 패킷을 만들어주는데 응답을 할 때 보내는 패킷의 Header 
    // ** 패킷에 대한 설명 추가로 유튜브에 찾아보기 

    // 응답하는 패킷의 header값을 설정 
    // {} 안에는 header값 중에서 속성이 있음
    // Content-Type이라는 속성 : 어떤 파일을 응답해줄건지 지정! 
    // 응답하는 페이지를 글자로 이루어져 있는 html 파일을 만들어줄 것, 이 파일의 인코딩 방식은 utf-8로 

    // 네이버 메인페이지 -> F12 -> 어떻게 패킷, 헤더값을 주고받는지 확인? Naver 메인페이지 새로고침 
    //  -> 1초 이내에 많은 일들! -> Network 0.5초안에 서버에서 이루어지는 흐름들 
    // 가장 위 -> www.naver.com -> 클릭! Header가 뜸 네이버 서버에서 우리에게 보내온 패킷의 헤더값 
    // Status Code 200 : 응답하는 상태에 대한 번호, 정상적으로 응답이 됐다 
    // content-type : 우리가 한 것과 같음 

    // ** 패킷 (Header/Body)
    // ** writeHead() 패킷의 Header값을 지정해주는 것 
    // 200이라는건 ? 이 응답은 정상적이라는걸 알려주는 것 
    // 이 정보들, 이 패킷을 사용자에게 보여주는 것 

    // 우리눈에는 보이지 않지만 비어있는 HTML 파일이 생성이 됨 -> 이제 안에다 글씨를 써보자! 
    response.write('<html>');
        response.write('<body>');
            response.write('환영합니다!');
            // 중요한 것! 응답하는게 생기니까 계속해서 새로고침 되던 아이콘이 사라짐! 
            // 가장 기본적인 request, response 끝! 
            response.write('<br>');
            response.write('당신의 ip는 '+ip_res+'입니다.');
        response.write('</body>');
    response.write('</html>');
    
    // 모든 응답에 대한 코드가 정의되었을 때 마무리해주는 함수.
    response.end();


    // 5500 vs 3000 두개 켜서 비교 
    // 1은 html 2는 Nodejs서버로 새로 만들어준 html 
    // 1번은 아무리 접근을 해도 같은 값만 뜬다. -> 정적페이지
    // 2번은 누가 응답하냐에 따라서 값이 달라진다 -> 동적 페이지 

    // >> Next : input태그를 이용해서 사용자에게 값을 입력받아서 (다음시간) >>
    // 그 값을 Node.js 서버로 넘겨주면 넘겨준 값을 DB에 저장을 할거에요 (나중에)
}).listen(3000);

